# Call the function with your matrix
plot_xy_map(xy_map)
#xy_map <- t(x_reconstruction)%*%y_reconstruction
#xy_map <- result_soroush$vector_pc %*% t(result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000)))
xy_map <- result_soroush$vector_pc %*%  sweep(t(result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))), 2, result_soroush$mean_mfd[,1]$eval(seq(0,1,length=1000)), "+")
# Call the function with your matrix
plot_xy_map(xy_map)
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf,]
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(7, 3))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "Time (min)", ylab = "Value")
}
par(mfrow = c(1, 1))
}
plot_xy_map(xy_map_original)
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf[1:4],]
plot_xy_map(xy_map_original)
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf[1:3],]
plot_xy_map(xy_map_original)
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(1, 3))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "Time (min)", ylab = "Value")
}
par(mfrow = c(1, 1))
}
# original data
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf[1:3],]
plot_xy_map(xy_map_original)
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(2, 3))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "Time (min)", ylab = "Value")
}
par(mfrow = c(1, 1))
}
# original data
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf[1:6],]
plot_xy_map(xy_map_original)
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(7, 3),mar = c(1, 1, 2, 1))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "", ylab = "")
}
par(mfrow = c(1, 1))
}
# original data
xy_map_original <- t(x)%*%y
rownames(xy_map_original) <- gsub("_YPD", "", rownames(xy_map_original))
xy_map_original <- xy_map_original[significant_tf,]
plot_xy_map(xy_map_original)
vector_data <- x
scaling_factor_vector <- sqrt(mean(diag(var(vector_data))))
v1 <- t(y)
scaling_factor_tfunction <- sqrt(mean(diag(var(v1))))
v1 |> dim()
y |> dim()
result_soroush$lsv |> dim()
(result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))) |> dim()
(result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))) %*% t(result_soroush$lsv) |> dim()
# reconstruct using 4 pc
v_reconstruction <- (result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))) %*% t(result_soroush$lsv)
v_reconstruction <- v_reconstruction * scaling_factor_tfunction
y_reconstruction <- t(v_reconstruction)
y_reconstruction <- sweep(y_reconstruction, 2, result_soroush$mean_mfd[,1]$eval(seq(0,1,length=1000)), "+")
x_reconstruction <- result_soroush$lsv%*%t(result_soroush$vector_pc)
x_reconstruction <- x_reconstruction * scaling_factor_vector
y_reconstruction |> dim()
x_reconstruction |> dim()
xy_map <- t(x_reconstruction)%*%y_reconstruction
xy_map |> dim()
xy_map_reconstrion4 <- t(x_reconstruction)%*%y_reconstruction
v_reconstruction4 <- (result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))) %*% t(result_soroush$lsv)
v_reconstruction4 <- v_reconstruction4 * scaling_factor_tfunction
y_reconstruction4 <- t(v_reconstruction4)
y_reconstruction4 <- sweep(y_reconstruction4, 2, result_soroush$mean_mfd[,1]$eval(seq(0,1,length=1000)), "+")
x_reconstruction4 <- result_soroush$lsv%*%t(result_soroush$vector_pc)
x_reconstruction4 <- x_reconstruction4 * scaling_factor_vector
xy_map_reconstrion4 <- t(x_reconstruction4)%*%y_reconstruction4
v_reconstruction4 <- (result_soroush$pc_mfd[,1]$eval(seq(0,1,length=1000))) %*% t(result_soroush$lsv)
v_reconstruction4 <- v_reconstruction4 * scaling_factor_tfunction
y_reconstruction4 <- t(v_reconstruction4)
y_reconstruction4 <- sweep(y_reconstruction4, 2, result_soroush$mean_mfd[,1]$eval(seq(0,1,length=1000)), "+")
x_reconstruction4 <- result_soroush$lsv%*%t(result_soroush$vector_pc)
x_reconstruction4 <- x_reconstruction4 * scaling_factor_vector
xy_map_reconstrion4 <- t(x_reconstruction4)%*%y_reconstruction4
rownames(xy_map_reconstrion4) <- gsub("_YPD", "", rownames(xy_map_reconstrion4))
xy_map_reconstrion4 <- xy_map_reconstrion4[significant_tf,]
plot_xy_map(xy_map_reconstrion4)
library(ggplot2)
library(dplyr)
loading_df <- as.data.frame(result_soroush$vector_pc)
colnames(loading_df) <- c("PC1","PC2","PC3","PC4","PC5")
###########################
top_n <- 20  # You can adjust this number as needed
# Select the top N features for each principal component
loadings_melt_top <- loadings_melt %>%
group_by(Principal_Component) %>%
arrange(desc(abs(Loading))) %>%
slice_head(n = top_n)
# par(mfrow = c(1, 2))
# result_yue$pc_mfd[,1]$eval(list(t <- seq(t0_f, t1_f, length.out = grid_point)))[,2] |> plot(type="l")
# result_soroush$pc_mfd[,1]$eval(list(t <- seq(t0_f, t1_f, length.out = grid_point)))[,1] |> plot(type="l")
############################################
library(ggplot2)
library(dplyr)
loading_df <- as.data.frame(result_soroush$vector_pc)
colnames(loading_df) <- c("PC1","PC2","PC3","PC4","PC5")
colnames(loading_df) <- c("PC1","PC2","PC3","PC4")
get_top_features <- function(loadings, pc, top_n = 3) {
loadings %>%
select(all_of(pc)) %>%
mutate(Feature = rownames(.)) %>%
arrange(desc(abs(.data[[pc]]))) %>%
slice(1:top_n) %>%
select(Feature, !!sym(pc))
}
significant_tf <- c("ACE2", "SWI4", "SWI5", "SWI6", "MBP1", "STB1", "FKH1", "FKH2",
"NDD1", "MCM1", "ABF1", "BAS1", "CBF1", "GCN4", "GCR1", "GCR2",
"LEU3", "MET31", "REB1", "SKN7", "STE12")
# Identify top 3 features for PC1, PC2, PC3
top_pc1 <- get_top_features(loading_df, "PC1", 25)
top_pc1
which(top_pc1$PC1==max(top_pc1$PC1))
# largest TF
result_soroush$lsv |> dim()
# largest TF
result_soroush$vector_pc |> dim()
# largest TF
result_soroush$vector_pc |> head()
# largest TF
result_soroush$vector_pc[order(-abs(result_soroush$vector_pc[,1]))[1:106],]
# largest TF
sorted_tf_pc <- result_soroush$vector_pc[order(-abs(result_soroush$vector_pc[,1]))[1:106],]
rownames(sorted_tf_pc) <- gsub("_YPD", "", rownames(sorted_tf_pc))
is_in_names_vector <- rownames(sorted_tf_pc) %in% significant_tf
is_in_names_vector
sorted_tf_pc_ind <- cbind(sorted_tf_pc,rownames(sorted_tf_pc) %in% significant_tf)
sorted_tf_pc_ind
sorted_tf_pc_ind |> head(30)
library(pander)
pander(sorted_tf_pc_ind)
pander(sorted_tf_pc_ind, file = "table.md")
pander(sorted_tf_pc_ind, file = "/Users/soroush/Downloads/table.md")
html_table <- pandoc.table.return(sorted_tf_pc_ind, style = "rmarkdown")
cat(html_table, file = "/Users/soroush/Downloads/table.html")
write.csv(sorted_tf_pc_ind, "/Users/soroush/Downloads/table.csv", row.names = TRUE)
library(spls)
data("yeast")
# ChIP-chip data
x <- yeast$x
# gene expression functional 542 genes and and each column is mrna level measure at each 7 minutes
y <- yeast$y
rm(yeast)
# Create B-spline basis and multivariate functional data (mfd) objects
v1 <- t(y)
scaling_factor_tfunction <- sqrt(mean(diag(var(v1))))
v1 <- 1/sqrt(mean(diag(var(v1))))*v1
nbasis_f <- 10
t0_f <- 0
t1_f <- 119
grid_point <- ncol(y)
t <- seq(t0_f, t1_f, length.out = grid_point)
bspline_basis <- fda::create.bspline.basis(c(t0_f,t1_f),nbasis_f)
mfd_basis <- ReMFPCA::basismfd$new(bspline_basis)
mfd_v1 <- ReMFPCA::mfd$new(t,v1,mfd_basis)
Mvmfd_obj <- ReMFPCA::mvmfd$new(list(mfd_v1,mfd_v1))
#vector data
vector_data <- x
scaling_factor_vector <- sqrt(mean(diag(var(vector_data))))
vector_data <- 1/scaling_factor_vector*vector_data
alpha2$a1
result_soroush$smooth_tuning
result_soroush_small_alpha <- ReMFPCA::Remfpca(mvmfd_obj = Mvmfd_obj,ncomp = 4,smooth_tuning = c(0.0009765625,0.0009765625,0.0009765625,0.0009765625),sparse_tuning = 0,vdata = vector_data)
result_soroush_small_alpha$vector_pc
xy_small <- t(x_small)%*%y_small
y_small <- result_soroush_small_alpha$lsv%*%t(result_soroush_small_alpha$pc_mfd[,1]$eval(seq(0,1,length=1000)))
x_small <- result_soroush_small_alpha$lsv%*%t(result_soroush_small_alpha$vector_pc)
xy_small <- t(x_small)%*%y_small
xy_small
xy_small |> dim()
xy_small |> rownames()
xy_small["FKH2_YPD",]
xy_small["FKH2_YPD",] |> plot(type="l")
getwd()
library(ReMFPCA)
library(spls)
data("yeast")
# ChIP-chip data
x <- yeast$x
# gene expression functional 542 genes and and each column is mrna level measure at each 7 minutes
y <- yeast$y
rm(yeast)
# Create B-spline basis and multivariate functional data (mfd) objects
v1 <- t(y)
scaling_factor_tfunction <- sqrt(mean(diag(var(v1))))
v1 <- 1/sqrt(mean(diag(var(v1))))*v1
nbasis_f <- 10
t0_f <- 0
t1_f <- 119
grid_point <- ncol(y)
t <- seq(t0_f, t1_f, length.out = grid_point)
bspline_basis <- fda::create.bspline.basis(c(t0_f,t1_f),nbasis_f)
mfd_basis <- ReMFPCA::basismfd$new(bspline_basis)
mfd_v1 <- ReMFPCA::mfd$new(t,v1,mfd_basis)
Mvmfd_obj <- ReMFPCA::mvmfd$new(list(mfd_v1,mfd_v1))
#vector data
vector_data <- x
scaling_factor_vector <- sqrt(mean(diag(var(vector_data))))
vector_data <- 1/scaling_factor_vector*vector_data
#model
alpha2 <- list(a1 = 2^seq(-10, 3, length.out = 20),a2 = 2^seq(-10, 3, length.out = 20))
result_yue <- ReMFPCA::Remfpca(mvmfd_obj = Mvmfd_obj,ncomp = 4,smooth_tuning = alpha2,sparse_tuning = 0)
result_soroush <- ReMFPCA::Remfpca(mvmfd_obj = Mvmfd_obj,ncomp = 4,smooth_tuning = alpha2,sparse_tuning = 0,vdata = vector_data)
y_reconstruction <- result_soroush$lsv%*%t(result_soroush$pc_mfd[,1]$eval(seq(0,119,length=1000)))
#y_reconstruction <- sweep(y_reconstruction, 2, result_soroush$mean_mfd[,1]$eval(seq(0,119,length=1000)), "+")
x_reconstruction <- result_soroush$lsv%*%t(result_soroush$vector_pc)
xy_map <- t(x_reconstruction)%*%y_reconstruction
rownames(xy_map) <- gsub("_YPD", "", rownames(xy_map))
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(7, 3),mar = c(1, 1, 2, 1))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "", ylab = "")
}
par(mfrow = c(1, 1))
}
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
# par(mfrow = c(7, 3),mar = c(1, 1, 2, 1))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "", ylab = "")
}
#par(mfrow = c(1, 1))
}
plot_xy_map(xy_map)
xy_map |> dim()
x |> rownames()
y |> rownames()
data("yeast")
yeast$x |> dim()
yeast$y |> colnames()
yeast$y |> rownames()
?yeast
class(yeast)
rm(yeast)
install.packages("dtwclust")
sil_width <- numeric(10)
for(k in 2:10){
pam_fit <- tsclust(xy_map, type = "partitional", k = k,
distance = "dtw", centroid = "pam", seed = 123)
sil_width[k] <- pam_fit@silinfo$avg.width
}
# xy_map clustering -------------------------------------------------------
library(dtwclust)
library(ggplot2)
library(dplyr)
sil_width <- numeric(10)
for(k in 2:10){
pam_fit <- tsclust(xy_map, type = "partitional", k = k,
distance = "dtw", centroid = "pam", seed = 123)
sil_width[k] <- pam_fit@silinfo$avg.width
}
pam_fit
sil_width
numeric(10)
?tsclust
pam_fit <- tsclust(xy_map, type = "partitional", k = 2,
distance = "dtw", centroid = "pam", seed = 123)
pam_fit
pam_fit@iter
pam_fit@converged
pam_fit@clusinfo
pam_fit@cldist
pam_fit@call
pam_fit@family
pam_fit@cluster
pam_fit@dots
pam_fit@args
pam_fit@cluster
cbind(rownames(xy_map),pam_fit@cluster)
significant_tf <- c("ACE2", "SWI4", "SWI5", "SWI6", "MBP1", "STB1", "FKH1", "FKH2",
"NDD1", "MCM1", "ABF1", "BAS1", "CBF1", "GCN4", "GCR1", "GCR2",
"LEU3", "MET31", "REB1", "SKN7", "STE12")
significant_tf
rownames(xy_map)
cbind(rownames(xy_map),pam_fit@cluster,ifelse(rownames(xy_map) %in% significant_tf,"yes","no"))
pam_fit@cluster |> table
pam_fit@cluster |> table()
ensure_positive_inner_product <- function(mat, vec) {
inner_products <- mat %*% vec
neg_rows <- inner_products < 0
if (any(neg_rows)) {
mat[neg_rows, ] <- -mat[neg_rows, ]
}
return(mat)
}
adj_sign <- function(mat, vec) {
inner_products <- mat %*% vec
neg_rows <- inner_products < 0
if (any(neg_rows)) {
mat[neg_rows, ] <- -mat[neg_rows, ]
}
return(mat)
}
adj_sign <- function(mat, vec) {
inner_products <- mat %*% vec
neg_rows <- inner_products < 0
if (any(neg_rows)) {
mat[neg_rows, ] <- -mat[neg_rows, ]
}
return(mat)
}
xy_map_adj <- adj_sign(xy_mp,xy_map[1,])
xy_map_adj <- adj_sign(xy_map,xy_map[1,])
all.equal(xy_map,xy_map_adj)
adj_sign <- function(mat, vec) {
inner_products <- mat %*% vec
print(inner_products)
neg_rows <- inner_products < 0
if (any(neg_rows)) {
mat[neg_rows, ] <- -mat[neg_rows, ]
}
return(mat)
}
xy_map_adj <- adj_sign(xy_map,xy_map[1,])
adj_sign <- function(mat, vec) {
inner_products <- mat %*% vec
print(inner_products)
neg_rows <- inner_products < 0
if (any(neg_rows)) {
mat[neg_rows, ] <- -mat[neg_rows, ]
}
return(mat)
}
xy_map_adj <- adj_sign(xy_map,xy_map[1,])
pam_fit <- tsclust(xy_map_adj, type = "partitional", k = 2,
distance = "dtw", centroid = "pam", seed = 123)
pam_fit@cluster
pam_fit@cluster |> table()
cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no"))
install.packages("flextable")
flextable::flextable(cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no")))
flextable::flextable(cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no")) |> as.data.frame())
ft <- flextable::flextable(cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no")) |> as.data.frame())
library(officer)
doc <- read_docx()
doc <- body_add_flextable(doc, value = ft)
library(flextable)
doc <- read_docx()
doc <- body_add_flextable(doc, value = ft)
print(doc, target = "/Users/soroush/Downloads/table_in_word.docx")
cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no")) |> as.data.frame()
df <- cbind(rownames(xy_map_adj),pam_fit@cluster,ifelse(rownames(xy_map_adj) %in% significant_tf,"yes","no")) |> as.data.frame()
summary(df)
install.packages("VennDiagram")
library(VennDiagram)
set1 <- df$V1[df$V2 == 1 & df$V3 == "yes"]
set2 <- df$V1[df$V2 == 1 & df$V3 == "no"]
set3 <- df$V1[df$V2 == 2 & df$V3 == "yes"]
set4 <- df$V1[df$V2 == 2 & df$V3 == "no"]
venn.plot <- venn.diagram(
x = list(
`cl1 TF_Yes` = set1,
`cl1 TF_No` = set2,
`cl2 TF_Yes` = set3,
`cl2 TF_No` = set4
),
category.names = c("cl1 TF_Yes", "cl1 TF_No", "cl2 TF_Yes", "cl2 TF_No"),
filename = NULL,
output = TRUE,
lwd = 2,
fill = c("red", "green", "blue", "yellow"),
alpha = 0.5,
cat.col = c("red", "green", "blue", "yellow"),
cat.cex = 1.5,
cat.pos = 0
)
# Plot the Venn diagram
grid.draw(venn.plot)
set1
set2
set1 <- df$V1[df$V2 == 1 & df$V3 == "yes"]
set1 <- df$V1[df$V2 == 1 & df$V3 == "yes"]
set1 <- df$V1[df$V2 == 1 & df$V3 == "yes"]
df$V1[df$V2 == 1 & df$V3 == "yes"]
df$V1[df$V2 == 1 & df$V3 == "no"]
df$V1[df$V2 == 2 & df$V3 == "yes"]
df$V1[df$V2 == 2 & df$V3 == "no"]
plot_xy_map(xy_map_adj)
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(7, 3),mar = c(1, 1, 2, 1))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "", ylab = "")
}
par(mfrow = c(1, 1))
}
plot_xy_map(xy_map_adj)
xy_map_adj |> dim()
significant_tf <- c("ACE2", "SWI4", "SWI5", "SWI6", "MBP1", "STB1", "FKH1", "FKH2",
"NDD1", "MCM1", "ABF1", "BAS1", "CBF1", "GCN4", "GCR1", "GCR2",
"LEU3", "MET31", "REB1", "SKN7", "STE12")
rownames(xy_map) <- gsub("_YPD", "", rownames(xy_map))
xy_map <- xy_map[significant_tf,]
xy_map_adj <- adj_sign(xy_map,xy_map[1,])
plot_xy_map(xy_map_adj)
for (1 in 1:nrow(xy_map_adj)) {
for (i in 1:nrow(xy_map_adj)) {
print(xy_map_adj[1,]*xy_map_adj[i,])
}
for (i in 1:nrow(xy_map_adj)) {
print(xy_map_adj[1,]*xy_map_adj[i,] |> sum())
}
for (i in 1:nrow(xy_map_adj)) {
print(sum(xy_map_adj[1,]*xy_map_adj[i,]))
}
xy_map <- t(x_reconstruction)%*%y_reconstruction
xy_map <- xy_map[-significant_tf,]
significant_tf
xy_map
xy_map |> rownames()
rownames(xy_map) <- gsub("_YPD", "", rownames(xy_map))
xy_map <- xy_map[-significant_tf,]
xy_map[-significant_tf,]
xy_map <- xy_map[-(significant_tf),]
xy_map <- xy_map[(significant_tf),]
xy_map <- t(x_reconstruction)%*%y_reconstruction
significant_tf <- c("ACE2", "SWI4", "SWI5", "SWI6", "MBP1", "STB1", "FKH1", "FKH2",
"NDD1", "MCM1", "ABF1", "BAS1", "CBF1", "GCN4", "GCR1", "GCR2",
"LEU3", "MET31", "REB1", "SKN7", "STE12")
rownames(xy_map) <- gsub("_YPD", "", rownames(xy_map))
kkk <- setdiff(rownames(xy_map),significant_tf)
kkk
xy_map <- xy_map[kkk,]
plot_xy_map(xy_map[1:21,])
xy_map <- t(x_reconstruction)%*%y_reconstruction
significant_tf <- c("ACE2", "SWI4", "SWI5", "SWI6", "MBP1", "STB1", "FKH1", "FKH2",
"NDD1", "MCM1", "ABF1", "BAS1", "CBF1", "GCN4", "GCR1", "GCR2",
"LEU3", "MET31", "REB1", "SKN7", "STE12")
rownames(xy_map) <- gsub("_YPD", "", rownames(xy_map))
xy_map <- xy_map[(significant_tf),]
# Example function to plot each row of xy_map
plot_xy_map <- function(xy_map, time_points = seq(0, 119, length.out = ncol(xy_map))) {
par(mfrow = c(7, 3),mar = c(1, 1, 2, 1))
row_names <- rownames(xy_map)
for (i in 1:nrow(xy_map)) {
plot(time_points, xy_map[i, ], type = "l",
main = row_names[i], xlab = "", ylab = "")
}
par(mfrow = c(1, 1))
}
xy_map_adj <- adj_sign(xy_map,xy_map[1,])
plot_xy_map(xy_map_adj)
xy_map_adj
xy_map_adj |> dim()
library(spls)
data("yeast")
# ChIP-chip data
x <- yeast$x
# gene expression functional 542 genes and and each column is mrna level measure at each 7 minutes
y <- yeast$y
rm(yeast)
# Create B-spline basis and multivariate functional data (mfd) objects
v1 <- t(y)
scaling_factor_tfunction <- sqrt(mean(diag(var(v1))))
v1 <- 1/sqrt(mean(diag(var(v1))))*v1
nbasis_f <- 10
t0_f <- 0
t1_f <- 119
grid_point <- ncol(y)
t <- seq(t0_f, t1_f, length.out = grid_point)
bspline_basis <- fda::create.bspline.basis(c(t0_f,t1_f),nbasis_f)
mfd_basis <- ReMFPCA::basismfd$new(bspline_basis)
mfd_v1 <- ReMFPCA::mfd$new(t,v1,mfd_basis)
Mvmfd_obj <- ReMFPCA::mvmfd$new(list(mfd_v1,mfd_v1))
#vector data
vector_data <- x
scaling_factor_vector <- sqrt(mean(diag(var(vector_data))))
vector_data <- 1/scaling_factor_vector*vector_data
#model
alpha2 <- list(a1 = 2^seq(-10, 3, length.out = 20),a2 = 2^seq(-10, 3, length.out = 20))
result_yue <- ReMFPCA::Remfpca(mvmfd_obj = Mvmfd_obj,ncomp = 4,smooth_tuning = alpha2,sparse_tuning = 0)
result_soroush <- ReMFPCA::Remfpca(mvmfd_obj = Mvmfd_obj,ncomp = 4,smooth_tuning = alpha2,sparse_tuning = 0,vdata = vector_data)
library("ReMFPCA")
